= Spring Boot Modular Application dengan PF4J =

== Pendahuluan ==

Dokumen ini menjelaskan arsitektur aplikasi modular berbasis '''Spring Boot 3.4''' dan '''PF4J (Plugin Framework for Java)'''. Arsitektur ini memungkinkan penambahan fitur baru sebagai plugin tanpa harus mengompilasi ulang aplikasi utama.

== Gambaran Umum ==

Sistem terdiri dari 3 modul Maven dalam satu parent project:

{| class="wikitable" style="width:100%"
! Modul !! Artifact ID !! Fungsi
|-
| '''Core App''' || <code>core-app</code> || Aplikasi utama Spring Boot. Memuat plugin, menyediakan database, dan menjalankan web server.
|-
| '''Plugins API''' || <code>plugins-api</code> || Kontrak/interface yang menjadi jembatan antara core dan plugin. Berisi extension point.
|-
| '''Plugin Inventory''' || <code>plugin-inventory</code> || Plugin contoh yang menyediakan CRUD inventory (Controller, Repository, Entity).
|}

== Teknologi ==

{| class="wikitable"
! Komponen !! Teknologi !! Versi
|-
| Framework || Spring Boot || 3.4.0
|-
| Plugin Framework || PF4J (via pf4j-spring) || 0.8.0 (PF4J 3.8.0)
|-
| Database || H2 (file-based) || 2.3.x
|-
| ORM || Hibernate (Spring Data JPA) || 6.6.x
|-
| Java || OpenJDK || 17+
|-
| Build Tool || Apache Maven || 3.x
|}

== Arsitektur ==

=== Diagram Modul ===

<pre>
┌─────────────────────────────────────────────────────────┐
│                     Parent POM                          │
│                   (modular-app)                         │
│                                                         │
│  ┌──────────────┐  ┌──────────────┐  ┌───────────────┐ │
│  │  plugins-api  │  │   core-app   │  │   plugin-     │ │
│  │              │  │              │  │   inventory   │ │
│  │  Extension   │  │  Spring Boot │  │              │ │
│  │  Point       │◄─┤  Application │  │  Controller  │ │
│  │  Interface   │  │              │  │  Repository  │ │
│  │              │  │  Composite   │  │  Entity      │ │
│  │              │◄─┼──────────────┼──┤              │ │
│  └──────────────┘  └──────┬───────┘  └──────┬────────┘ │
│                           │                 │          │
│                           │    ┌────────────┘          │
│                           │    │  JAR di folder        │
│                           │    │  plugins/             │
│                           ▼    ▼                       │
│                    ┌──────────────┐                     │
│                    │  Runtime:    │                     │
│                    │  PF4J loads  │                     │
│                    │  plugin JAR  │                     │
│                    └──────────────┘                     │
└─────────────────────────────────────────────────────────┘
</pre>

=== Dependency Antar Modul ===

<pre>
core-app ───depends──► plugins-api ───depends──► pf4j-spring
                                                      │
plugin-inventory ──depends (provided)──► plugins-api   │
                 ──depends (provided)──► spring-boot   │
                                                      ▼
                                                    pf4j
</pre>

'''Catatan:''' Plugin menggunakan scope <code>provided</code> untuk semua dependency yang sudah ada di core-app, agar JAR plugin tetap kecil dan tidak duplikasi library.

== Mekanisme Composite ClassLoader ==

=== Masalah ===

PF4J memuat plugin JAR menggunakan '''classloader terpisah''' (<code>PluginClassLoader</code>). Spring Boot component scan hanya bisa menemukan class dari application classloader. Akibatnya:

* <code>@RestController</code> dari plugin → tidak terdaftar di DispatcherServlet → '''HTTP 404'''
* <code>@Repository</code> dari plugin → tidak terdaftar sebagai Spring Data repository
* <code>@Entity</code> dari plugin → tidak terdeteksi oleh Hibernate entity scan

=== Solusi ===

Aplikasi menggunakan '''CompositeClassLoader''' yang menggabungkan application classloader dengan semua plugin classloader. Ini memungkinkan Spring Boot melihat class dari plugin secara natural.

<pre>
┌─────────────────────────────────────────┐
│          CompositeClassLoader           │
│                                         │
│  ┌─────────────────┐                   │
│  │  Parent:         │  ← Spring, JPA,  │
│  │  App ClassLoader │    Core classes   │
│  └─────────────────┘                   │
│                                         │
│  ┌─────────────────┐                   │
│  │  Delegate 1:     │  ← Plugin        │
│  │  PluginCL #1     │    classes        │
│  └─────────────────┘                   │
│                                         │
│  ┌─────────────────┐                   │
│  │  Delegate N:     │  ← Plugin        │
│  │  PluginCL #N     │    classes        │
│  └─────────────────┘                   │
└─────────────────────────────────────────┘
</pre>

=== Urutan Startup ===

{| class="wikitable" style="width:100%"
! # !! Langkah !! Keterangan
|-
| 1 || <code>DefaultPluginManager</code> dibuat || Memuat plugin JAR dari folder <code>plugins/</code>
|-
| 2 || <code>loadPlugins()</code> || PF4J membuat <code>PluginClassLoader</code> untuk setiap JAR
|-
| 3 || <code>startPlugins()</code> || Memanggil <code>Plugin.start()</code> pada setiap plugin
|-
| 4 || <code>CompositeClassLoader</code> dibuat || Menggabungkan app classloader + semua plugin classloader
|-
| 5 || Set sebagai thread context classloader || Agar semua framework menggunakan composite classloader
|-
| 6 || <code>SpringApplication.run()</code> || Spring Boot mulai, menggunakan composite classloader untuk scanning
|-
| 7 || Component scan menemukan plugin beans || <code>@RestController</code>, <code>@Repository</code>, <code>@Entity</code> dari plugin terdeteksi
|-
| 8 || PluginManager di-register sebagai singleton || Tersedia untuk injection di beans lain
|}

== Struktur Proyek ==

<pre>
spring-modular-pf4j/
├── pom.xml                          ← Parent POM
│
├── plugins-api/                     ← Kontrak interface
│   ├── pom.xml
│   └── src/main/java/com/example/api/
│       ├── AppExtension.java        ← ExtensionPoint interface
│       └── model/
│           └── ModuleInfo.java      ← Record untuk info modul
│
├── core-app/                        ← Aplikasi utama
│   ├── pom.xml
│   ├── plugins/                     ← Folder untuk plugin JAR
│   │   └── plugin-inventory-1.0.0.jar
│   └── src/main/java/com/example/core/
│       ├── CoreApplication.java     ← Main class + plugin loading
│       ├── classloader/
│       │   └── CompositeClassLoader.java
│       ├── config/
│       │   └── PluginConfig.java
│       └── controller/
│           └── CoreController.java  ← Health check endpoint
│
└── plugin-inventory/                ← Plugin contoh
    ├── pom.xml
    └── src/main/java/com/example/inventory/
        ├── InventoryModule.java     ← PF4J Plugin class
        ├── controller/
        │   └── InventoryController.java
        ├── model/
        │   └── InventoryItem.java   ← JPA Entity
        └── repository/
            └── InventoryRepository.java
</pre>

== Detail Modul ==

=== Core App ===

==== CoreApplication.java ====

Class utama aplikasi. Bertanggung jawab untuk:

# Membuat <code>DefaultPluginManager</code> dan memuat plugin
# Membuat <code>CompositeClassLoader</code>
# Men-start Spring Boot dengan composite classloader
# Mendaftarkan <code>PluginManager</code> sebagai singleton bean

Annotations penting:
* <code>@SpringBootApplication(scanBasePackages = "com.example")</code> — scan semua package <code>com.example.*</code>
* <code>@EntityScan(basePackages = "com.example")</code> — scan JPA entity dari semua package
* <code>@EnableJpaRepositories(basePackages = "com.example")</code> — scan Spring Data repository dari semua package

<syntaxhighlight lang="java">
@EntityScan(basePackages = "com.example")
@EnableJpaRepositories(basePackages = "com.example")
@SpringBootApplication(scanBasePackages = "com.example")
public class CoreApplication {

    public static void main(String[] args) {
        // 1. Load plugin sebelum Spring start
        DefaultPluginManager pluginManager = new DefaultPluginManager(Paths.get("plugins"));
        pluginManager.loadPlugins();
        pluginManager.startPlugins();

        // 2. Buat composite classloader
        ClassLoader appClassLoader = Thread.currentThread().getContextClassLoader();
        List<ClassLoader> pluginClassLoaders = new ArrayList<>();
        for (PluginWrapper plugin : pluginManager.getStartedPlugins()) {
            pluginClassLoaders.add(plugin.getPluginClassLoader());
        }
        CompositeClassLoader compositeClassLoader =
            new CompositeClassLoader(appClassLoader, pluginClassLoaders);

        Thread.currentThread().setContextClassLoader(compositeClassLoader);

        // 3. Start Spring Boot
        SpringApplication app = new SpringApplication(
            new DefaultResourceLoader(compositeClassLoader),
            CoreApplication.class
        );
        app.addInitializers(ctx -> {
            ctx.getBeanFactory().registerSingleton("pluginManager", pluginManager);
        });
        app.run(args);
    }
}
</syntaxhighlight>

==== CompositeClassLoader.java ====

ClassLoader kustom yang mendelegasikan pencarian class dan resource ke beberapa classloader. Flow:

# Parent classloader (app classloader) dicoba terlebih dahulu
# Jika tidak ditemukan, delegasikan ke plugin classloader satu per satu

Tiga method utama yang di-override:

{| class="wikitable" style="width:100%"
! Method !! Fungsi
|-
| <code>findClass(String)</code> || Mencari class definition dari plugin classloaders
|-
| <code>findResource(String)</code> || Mencari single resource (file) dari plugin classloaders
|-
| <code>findResources(String)</code> || Mengumpulkan semua resource dari semua plugin classloaders (digunakan oleh Spring classpath scanner)
|}

==== CoreController.java ====

REST controller untuk health check:

{| class="wikitable"
! Endpoint !! Method !! Keterangan
|-
| <code>/api/health</code> || GET || Menampilkan status aplikasi dan daftar plugin yang aktif
|}

=== Plugins API ===

==== AppExtension.java ====

Interface extension point yang harus diimplementasi oleh setiap plugin:

<syntaxhighlight lang="java">
public interface AppExtension extends ExtensionPoint {
    String getModuleName();
    String getModuleDescription();
}
</syntaxhighlight>

=== Plugin Inventory ===

==== InventoryModule.java ====

Entry point plugin, extends <code>org.pf4j.Plugin</code>. MANIFEST.MF di JAR berisi:

<pre>
Plugin-Id: inventory-plugin
Plugin-Version: 1.0.0
Plugin-Class: com.example.inventory.InventoryModule
</pre>

==== InventoryController.java ====

REST controller untuk CRUD inventory:

{| class="wikitable" style="width:100%"
! Endpoint !! Method !! Keterangan
|-
| <code>/api/inventory</code> || GET || Mendapatkan semua item inventory
|-
| <code>/api/inventory</code> || POST || Menambah item baru (request body: JSON)
|-
| <code>/api/inventory/{id}</code> || GET || Mendapatkan detail item berdasarkan ID
|-
| <code>/api/inventory/{id}</code> || DELETE || Menghapus item berdasarkan ID
|}

==== InventoryItem.java ====

JPA Entity yang di-map ke tabel <code>inventory_items</code>:

{| class="wikitable"
! Field !! Tipe !! Keterangan
|-
| <code>id</code> || Long || Primary key, auto-generated
|-
| <code>name</code> || String || Nama barang (not null)
|-
| <code>quantity</code> || Integer || Jumlah stok
|-
| <code>price</code> || Double || Harga
|}

==== InventoryRepository.java ====

Spring Data JPA repository interface, extends <code>JpaRepository<InventoryItem, Long></code>.

== Konfigurasi ==

=== application.properties ===

<syntaxhighlight lang="properties">
spring.application.name=core-app
server.port=8080

# Database H2 (file-based, shared dengan plugin)
spring.datasource.url=jdbc:h2:file:./data/modular_db;DB_CLOSE_DELAY=-1
spring.datasource.driverClassName=org.h2.Driver
spring.datasource.username=sa
spring.datasource.password=

# Hibernate auto-update schema saat ada Entity baru dari plugin
spring.jpa.hibernate.ddl-auto=update
spring.jpa.show-sql=true

spring.main.allow-bean-definition-overriding=true
</syntaxhighlight>

=== Plugin POM Configuration ===

Dependency plugin menggunakan scope <code>provided</code> agar tidak dikemas dalam JAR plugin:

<syntaxhighlight lang="xml">
<dependencies>
    <dependency>
        <groupId>com.example</groupId>
        <artifactId>plugins-api</artifactId>
        <scope>provided</scope>
    </dependency>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-data-jpa</artifactId>
        <scope>provided</scope>
    </dependency>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-web</artifactId>
        <scope>provided</scope>
    </dependency>
</dependencies>
</syntaxhighlight>

MANIFEST.MF dikonfigurasi melalui <code>maven-jar-plugin</code>:

<syntaxhighlight lang="xml">
<plugin>
    <groupId>org.apache.maven.plugins</groupId>
    <artifactId>maven-jar-plugin</artifactId>
    <configuration>
        <archive>
            <manifestEntries>
                <Plugin-Id>inventory-plugin</Plugin-Id>
                <Plugin-Version>1.0.0</Plugin-Version>
                <Plugin-Class>com.example.inventory.InventoryModule</Plugin-Class>
            </manifestEntries>
        </archive>
    </configuration>
</plugin>
</syntaxhighlight>

== Build & Deployment ==

=== Build ===

<syntaxhighlight lang="bash">
# Build semua modul
cd spring-modular-pf4j
mvn clean package -DskipTests

# Copy JAR plugin ke folder plugins core-app
cp plugin-inventory/target/plugin-inventory-1.0.0.jar core-app/plugins/
</syntaxhighlight>

=== Run ===

<syntaxhighlight lang="bash">
# Jalankan dari direktori core-app
cd core-app
java -jar target/core-app-1.0.0.jar

# Atau menggunakan Maven
mvn spring-boot:run
</syntaxhighlight>

== Cara Menambah Plugin Baru ==

Untuk menambah plugin baru (misal: plugin-order), ikuti langkah berikut:

# Buat modul Maven baru di bawah parent project
# Tambahkan dependency <code>plugins-api</code>, <code>spring-boot-starter-web</code>, <code>spring-boot-starter-data-jpa</code> dengan scope <code>provided</code>
# Buat class Plugin yang extends <code>org.pf4j.Plugin</code>
# Buat Controller, Entity, dan Repository seperti biasa (menggunakan annotation Spring standar)
# Konfigurasi <code>maven-jar-plugin</code> dengan MANIFEST entries (<code>Plugin-Id</code>, <code>Plugin-Version</code>, <code>Plugin-Class</code>)
# Build dan copy JAR ke folder <code>core-app/plugins/</code>
# Restart aplikasi

'''Penting:''' Semua class di plugin harus berada di bawah package <code>com.example.*</code> agar terdeteksi oleh Spring component scan.

== Catatan Penting ==

=== ClassLoader Isolation ===

* Plugin di-load oleh PF4J menggunakan classloader terpisah (<code>PluginClassLoader</code>)
* <code>CompositeClassLoader</code> menjembatani gap antara plugin classloader dan Spring's classpath scanning
* Class yang di-share (Spring, JPA, plugins-api) di-resolve melalui parent classloader
* Class spesifik plugin di-resolve melalui plugin classloader masing-masing

=== Database Sharing ===

* Semua plugin menggunakan datasource yang sama dari core-app
* <code>spring.jpa.hibernate.ddl-auto=update</code> memastikan tabel baru otomatis dibuat saat ada Entity baru dari plugin
* Tidak perlu konfigurasi datasource terpisah di plugin

=== Limitasi ===

* Package plugin harus di bawah <code>com.example</code> (sesuai <code>scanBasePackages</code>)
* Perubahan plugin memerlukan restart aplikasi
* Plugin tidak bisa memiliki dependency yang konflik dengan core-app

[[Category:Architecture]]
[[Category:Spring Boot]]
[[Category:PF4J]]
